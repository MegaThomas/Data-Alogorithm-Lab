#include <iostream>
#include <string>
using namespace std;
template<class TYP>
struct Stack_Node
{
	TYP data;
	Stack_Node* next;
	Stack_Node* prev;
	//Stack_Node(){};
	Stack_Node(TYP i): data(i), next(NULL), prev(NULL) {};
};
template<class TYP>
class Stack{
private:
	Stack_Node<TYP>* bottom;
	Stack_Node<TYP>* top;
public:
	Stack()
	{
		bottom = new Stack_Node<TYP>(TYP(-1));
		bottom->data = TYP(-1);
		bottom->next = NULL;
		bottom->prev = NULL;
		top = bottom;
	}
	~Stack()
	{
		Stack_Node<TYP> *fron, *back;
		back = bottom;
		fron = bottom->next;
		while( fron != NULL )
		{
			delete []back;
			back = fron;
			fron = fron->next;			
		}
		delete []back;
	}
	int push( TYP src )
	{
		if( bottom->data == TYP(-1) ){
			bottom->data = src;
			top = bottom;
		}else{
			top->next = new Stack_Node<TYP>(TYP(-1));
			top->next->prev = top;
			top = top->next;
			top->data = src;
			top->next = NULL;
		}
		return 1;
	}
	TYP pop(void)
	{
		TYP temp = top->data;
		if( top == bottom ){
			top->data = TYP(0);
			top->next = bottom->next = NULL;
			top->prev = bottom->prev = NULL;
			return temp;
		}else{
			top = top->prev;
			delete []top->next;
			top->next = NULL;
			return temp;
		}
	}
};

struct BST_Node
{
	int data;
	BST_Node* left;
	BST_Node* right;
	int children;
	//BST_Node(): data(-1), left(NULL), right(NULL), children(-1) {};
};
class BST{
//private:
public:
	int height;
	int num;
	BST_Node* root;
	bool deleteTree(BST_Node* root);
	bool cloneTree(BST& src);
	int insert(int src, BST_Node* node);
//public:
	BST(): height(0), num(0) {
		root = new BST_Node;
		root->data = -1;
		root->left = root->right = NULL;
		root->children = -1;
	};
	~BST(){
		deleteTree(root);
	};
	BST( BST &src){
		cloneTree(src);
	};
	void insert(int);
	int getHeight();
	void preOrder( BST_Node *node, void (*func)(BST_Node*) );
	void postOrder( BST_Node *node, void (*func)(BST_Node*) );
	void inOrder( BST_Node *node, void (*func)(BST_Node*) );
	int countSubTree(BST_Node* root, BST_Node* tar);
	bool isSubTree(BST_Node* root, BST_Node *tar);
	void show( BST_Node* node );
};
bool BST::deleteTree( BST_Node* node )
{
	if( node->data == -1 ){
		delete []node;
		node = NULL;
		return true;
	}
	if( node->left != NULL ){
		this->deleteTree(node->left);
	}
	if( node->right != NULL ){
		this->deleteTree(node->right);
	}
	delete []node;
	return true;
}
void BST::insert( int src )
{
	this->num += 1;
	int newHeight = this->insert(src, this->root);
	height = (height > newHeight) ? height : newHeight;
}
int BST::insert( int src, BST_Node* node)
{
	node->children += 1;
	if( node->data == -1 ){// insert this node 
		node->data = src;
		node->left = node->right = NULL;
		node->children = 1;
		return 1;
	}
	if( node->data > src ){
		if( node->left != NULL ){
			return this->insert( src, node->left ) +1;
		}else{
			node->left = new BST_Node;
			node->left->data = src;
			node->left->left = node->left->right = NULL;
			node->left->children = 1;
			return 2;
		}
	}else{
		if( node->right != NULL ){
			return this->insert( src, node->right )+1;
		}else{
			node->right = new BST_Node;
			node->right->data = src;
			node->right->left = node->right->right = NULL;
			node->right->children = 1;
			return 2;
		}
	}
}
void BST::preOrder( BST_Node *node, void (*func)(BST_Node*) )
{
	func(node);
	if( node == NULL )
		return ;
	preOrder( node->left, func );
	preOrder( node->right, func );
}
void BST::inOrder( BST_Node *node, void (*func)(BST_Node*) )
{
	if( node == NULL )
	{
		func(node);
		return ;
	}
	inOrder( node->left, func );
	func(node);
	inOrder( node->right, func );
}
void BST::postOrder( BST_Node *node, void (*func)(BST_Node*) )
{
	if( node == NULL )
	{
		func(node);
		return ;
	}
	postOrder( node->left, func );
	postOrder( node->right, func );
	func(node);
}
int BST::getHeight()
{
	return this->height;
}
void show( BST_Node* node )
{
	if( node == NULL )
		cout<<'#'<<' ';
	else
		cout<<node->data<<' ';
}
int BST::countSubTree(BST_Node* root, BST_Node* tar)
{
	if( root == NULL || tar == NULL )
			return 0;
	int temp1 = countSubTree(root->left, tar);
	int temp2 = isSubTree( root, tar );
	int temp3 = countSubTree(root->right, tar);
	return temp1+temp2+temp3;
}
bool BST::isSubTree(BST_Node* root, BST_Node* tar)
{
	if( root == NULL )
		if( tar == NULL )
			return true;
		else
			return false;
	if( tar == NULL )
		if( root == NULL )
			return true;
		else
			return false;
	bool temp1 = isSubTree(root->left, tar->left);
	bool temp2 = ((root->left == NULL)^(tar->left ==NULL)) && ((root->right == NULL)^(tar->right ==NULL));
	bool temp3 = isSubTree(root->right,  tar->right);
	return temp1 && (!temp2) && temp3;
}


string tree_d, tree_sub;
void str_d( BST_Node* node )
{
	if( node == NULL )
		tree_d.append(1,'#');
	else
		tree_d.append(1,node->children+'0');
}
void str_sub( BST_Node* node )
{
	if( node == NULL )
		tree_sub.append(1,'#');
	else
		tree_sub.append(1,node->children+'0');
}
int main()
{
	BST tree, sub_tree;
	int input, len1, len2;
	cin>>len1;
	for( ; len1>0; len1-- )
	{
		cin>>input;
		tree.insert(input);
	}
	cin>>len2;
	for( ; len2>0; len2-- )
	{
		cin>>input;
		sub_tree.insert(input);
	}
	tree.preOrder(tree.root, &show );
	cout<<endl;
	tree.inOrder(tree.root, &show );
	cout<<endl;
	tree.postOrder(tree.root, &show );
	cout<<endl;
	cout<<tree.getHeight()<<endl;
	tree.preOrder(tree.root, &str_d );
	sub_tree.preOrder(sub_tree.root, &str_sub );
	int pattern=0, pos=-1;
	while(1){
		pos = tree_d.find(tree_sub,pos+1);
		if( pos != -1 )
			pattern++;
		else
			break;
	}
	cout<<pattern<<endl;
	cout<<tree.countSubTree(tree.root, sub_tree.root)<<endl;
	system("pause");
	return 0;
}
